# -*- coding: utf-8 -*-
"""ben's code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19dBXU-Ssf6k1ONLl4aZujcptqtueJI6Q
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
n = 1  # Principal quantum number
m = m_e  # Mass of electron
epsilon_0 = epsilon_0  # Vacuum permittivity
hbar = hbar  # Reduced Planck's constant

# Potential energy function for Hydrogen atom (Coulomb potential)
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial wave function for the ground state of Hydrogen atom
def R_nl(r, n, l):
    if n == 1 and l == 0:
        # Ground state wave function R_10(r)
        return (2 / a_0)**(3/2) * np.exp(-r / a_0)
    else:
        raise ValueError("Only ground state R_10 is implemented.")

# Bohr radius
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m * e**4)

# Energy calculation for the hydrogen atom
def energy(n):
    return -Z**2 * m * e**4 / (8 * epsilon_0**2 * hbar**2 * n**2)

# Calculate the energy of the ground state
E1 = energy(n)
print(f"Energy of the ground state (n={n}): {E1:.2e} J")
print(f"Energy in eV: {E1 / e:.2f} eV")

# Plotting the radial wave function
r = np.linspace(0.01, 20 * a_0, 100)  # Avoid r=0 to prevent singularity
R = R_nl(r, n, 0)

plt.plot(r/a_0, R**2)
plt.title('Radial Probability Density for Hydrogen Atom (Ground State)')
plt.xlabel('Radius (in units of Bohr radius)')
plt.ylabel('Probability Density')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions
    H[0, 0] = 1  # Dirichlet boundary condition at r=0
    H[-1, -1] = 1  # Dirichlet boundary condition at r=r_max

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number
l = 0  # Angular momentum quantum number
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0] / e  # Convert from Joules to eV
print(f"Ground state energy: {ground_state_energy:.2f} eV")

# Plotting the ground state wavefunction (normalized)
plt.plot(np.linspace(0.01, r_max, num_points), wavefunctions[:, 0]**2)
plt.title('Radial Probability Density for Hydrogen Atom Ground State')
plt.xlabel('Radius (m)')
plt.ylabel('Probability Density')
plt.xlim(0, r_max)
plt.grid()
plt.show()

def hydrogen_energy_level(n):
    """
    Calculate the energy level of a hydrogen atom.

    Parameters:
    n (int): Principal quantum number

    Returns:
    float: Energy in electron volts (eV)
    """
    # Energy level formula for hydrogen atom
    energy = -13.6 / (n ** 2)
    return energy

# Example usage
n = 1  # Ground state
energy = hydrogen_energy_level(n)
print(f"The energy level for n={n} is {energy} eV")

import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions (Dirichlet)
    H[0, 0] = 1
    H[-1, -1] = 1

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number
l = 0  # Angular momentum quantum number
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0] / e  # Convert from Joules to eV
print(f"Ground state energy: {ground_state_energy:.2f} eV")

# Plotting the ground state wavefunction (normalized)
plt.plot(np.linspace(0.01, r_max, num_points), wavefunctions[:, 0]**2)
plt.title('Radial Probability Density for Hydrogen Atom Ground State')
plt.xlabel('Radius (m)')
plt.ylabel('Probability Density')
plt.xlim(0, r_max)
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh

# Constants
hbar = 1.0545718e-34  # Reduced Planck's constant (J·s)
m = 9.10938356e-31     # Mass of electron (kg)
k = 8.9875517873681764e9  # Coulomb's constant (N·m²/C²)
e = 1.602176634e-19    # Elementary charge (C)

# Potential energy function for hydrogen atom
def potential(r):
    return -k * e**2 / r

# Discretization parameters
N = 1000  # Number of points
r_min = 1e-10  # Minimum radius (to avoid singularity at r=0)
r_max = 20e-10  # Maximum radius
dr = (r_max - r_min) / N  # Step size
r = np.linspace(r_min, r_max, N)  # Radial coordinates

# Construct the Hamiltonian matrix
H = np.zeros((N, N))

# Fill the Hamiltonian matrix
for i in range(N):
    if i > 0:
        H[i, i-1] = -hbar**2 / (2 * m * dr**2)
    H[i, i] = 2 * hbar**2 / (2 * m * dr**2) + potential(r[i])
    if i < N - 1:
        H[i, i+1] = -hbar**2 / (2 * m * dr**2)

# Solve the eigenvalue problem
eigenvalues, eigenvectors = eigh(H)

# Convert eigenvalues from Joules to eV
eigenvalues_eV = eigenvalues / e

# Print the first few energy levels
for n in range(5):
    print(f"Energy level {n+1}: {eigenvalues_eV[n]:.4f} eV")

# Plot the first wave function
plt.plot(r, eigenvectors[:, 0]**2)
plt.title('Probability Density of the Ground State Wave Function')
plt.xlabel('Radius (m)')
plt.ylabel('Probability Density')
plt.xscale('log')
plt.show()

import sympy as sp
from scipy.special import sph_harm
import numpy as np
import matplotlib.pyplot as plt

# Define variables
r, theta, phi, Z = sp.symbols('r theta phi Z', real=True, positive=True)  # Z for atomic number

# Define constants (e.g., Planck's constant h, mass of electron m)
hbar = 1.0545718e-34  # Reduced Planck constant (J s)
m_e = 9.10938356e-31  # Electron mass (kg)
e = 1.60217662e-19    # Elementary charge (C)
eps_0 = 8.85418782e-12 # Permittivity of free space (F/m)

# Define radial wave function (assuming ground state for simplicity)
n = 1  # Principal quantum number
l = 0  # Orbital quantum number for ground state
R_nl = sp.Function('R_nl')(r)  # Radial function to solve

# Radial Schrödinger equation in atomic units for hydrogen-like atom
# - (hbar^2 / (2 * m_e)) * (d^2/dr^2 + (2/r) * d/dr - l*(l+1)/r^2) * R_nl + (-Z*e^2/(4*sp.pi*eps_0*r)) * R_nl - E * R_nl = 0
E = sp.symbols('E')  # Energy eigenvalue

radial_eq = sp.Eq(- (hbar**2 / (2 * m_e)) * (sp.diff(R_nl, r, 2) + (2 / r) * sp.diff(R_nl, r) - (l * (l + 1) / r**2) * R_nl)
                   + (-Z * e**2 / (4 * sp.pi * eps_0 * r)) * R_nl, E * R_nl)

# Solve the radial equation
radial_solution = sp.dsolve(radial_eq)

# Print solution
print("Radial solution:", radial_solution)

import sympy as sp

# Define variables
r, Z = sp.symbols('r Z', real=True, positive=True)  # Z for atomic number
E = sp.symbols('E')  # Energy eigenvalue
R_nl = sp.Function('R_nl')(r)  # Radial function R(r) for hydrogen atom

# Define constants in atomic units
hbar = 1  # Planck's constant in atomic units (atomic units assume hbar = 1)
m_e = 1   # Electron mass in atomic units
e = 1     # Electron charge in atomic units
eps_0 = 1 # Permittivity of free space in atomic units

# Quantum numbers for hydrogen ground state (n=1, l=0)
n = 1
l = 0

# Define the radial Schrödinger equation for a hydrogen-like atom
radial_eq = sp.Eq(- (hbar**2 / (2 * m_e)) * (sp.diff(R_nl, r, 2) + (2 / r) * sp.diff(R_nl, r) - (l * (l + 1) / r**2) * R_nl)
                   + (-Z * e**2 / (4 * sp.pi * eps_0 * r)) * R_nl, E * R_nl)

# Solve the radial equation
radial_solution = sp.dsolve(radial_eq, R_nl)

# Print solution
print("Radial solution:", radial_solution)

import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions (Dirichlet)
    H[0, 0] = 1
    H[-1, -1] = 1

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number
l = 0  # Angular momentum quantum number
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0] / e  # Convert from Joules to eV
print(f"Ground state energy: {ground_state_energy:.2f} eV")

import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions (Dirichlet)
    H[0, 0] = 1
    H[-1, -1] = 1

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number
l = 0  # Angular momentum quantum number
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0] / e  # Convert from Joules to eV
print(f"Ground state energy: {ground_state_energy:.2f} eV")

import numpy as np
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions (Dirichlet)
    H[0, 0] = 1
    H[-1, -1] = 1

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number
l = 0  # Angular momentum quantum number
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0]  # Energy in Joules
ground_state_energy_eV = ground_state_energy / e  # Convert from Joules to eV
print(f"Ground state energy: {ground_state_energy_eV:.2f} eV")

import numpy as np
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions (Dirichlet)
    H[0, 0] = 1
    H[-1, -1] = 1

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number
l = 0  # Angular momentum quantum number
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0]  # Energy in Joules
ground_state_energy_eV = ground_state_energy / e  # Convert from Joules to eV
print(f"Ground state energy: {ground_state_energy_eV:.2f} eV")

import numpy as np
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions (Dirichlet)
    H[0, 0] = 1
    H[-1, -1] = 1

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number
l = 0  # Angular momentum quantum number
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0]  # Energy in Joules
ground_state_energy_eV = ground_state_energy / e  # Convert from Joules to eV
print(f"Ground state energy: {ground_state_energy_eV:.2f} eV")

# Debugging: Print the first few energies in Joules
print("First few energies in Joules:", energies[:5])

import numpy as np
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        # Kinetic energy term
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions (Dirichlet)
    H[0, 0] = 1
    H[-1, -1] = 1

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number
l = 0  # Angular momentum quantum number
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0]  # Energy in Joules
ground_state_energy_eV = ground_state_energy / e  # Convert from Joules to eV
print(f"Ground state energy: {ground_state_energy_eV:.2f} eV")

# Debugging: Print the first few energies in Joules
print("First few energies in Joules:", energies[:5])

print("Hamiltonian matrix:\n", H)

print("Raw energies in Joules:", energies)

import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions (Dirichlet)
    H[0, 0] = 1
    H[-1, -1] = 1

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number
l = 0  # Angular momentum quantum number
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0] / e  # Convert from Joules to eV
print(f"Ground state energy: {ground_state_energy:.2f} eV")

# Plotting the ground state wavefunction (normalized)
plt.plot(np.linspace(0.01, r_max, num_points), wavefunctions[:, 0]**2)
plt.title('Radial Probability Density for Hydrogen Atom Ground State')
plt.xlabel('Radius (m)')
plt.ylabel('Probability Density')
plt.xlim(0, r_max)
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import hbar, m_e, e, epsilon_0

# Constants
Z = 1  # Atomic number for Hydrogen
a_0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**4)  # Bohr radius in meters

# Define potential energy for hydrogen atom
def V(r):
    return -Z * e**2 / (4 * np.pi * epsilon_0 * r)

# Radial part of the Schrödinger equation using finite difference method
def solve_radial_schrodinger(n, l, r_max, num_points):
    r = np.linspace(0.01, r_max, num_points)  # Avoid r=0 to prevent singularity
    dr = r[1] - r[0]

    # Initialize the Hamiltonian matrix
    H = np.zeros((num_points, num_points))

    # Fill the Hamiltonian matrix using finite difference method
    for i in range(1, num_points - 1):
        H[i, i - 1] = -hbar**2 / (2 * m_e * dr**2)
        H[i, i] = 2 * hbar**2 / (2 * m_e * dr**2) + V(r[i])
        H[i, i + 1] = -hbar**2 / (2 * m_e * dr**2)

    # Apply boundary conditions (Dirichlet)
    H[0, 0] = 1
    H[-1, -1] = 1

    # Solve the eigenvalue problem
    energies, wavefunctions = np.linalg.eigh(H)

    return energies, wavefunctions

# Parameters for the calculation
n = 1  # Principal quantum number for ground state
l = 0  # Angular momentum quantum number for ground state
r_max = 20 * a_0  # Maximum radius in meters
num_points = 1000  # Number of points in the radial grid

# Solve the radial Schrödinger equation
energies, wavefunctions = solve_radial_schrodinger(n, l, r_max, num_points)

# Convert energy to eV and print the ground state energy
ground_state_energy = energies[0] / e  # Convert from Joules to eV

# Adjusting energy to match expected value by correcting for numerical errors
expected_energy = -13.6  # Expected ground state energy in eV

print(f"Calculated ground state energy: {ground_state_energy:.2f} eV")
print(f"Expected ground state energy: {expected_energy:.2f} eV")

# Plotting the ground state wavefunction (normalized)
plt.plot(np.linspace(0.01, r_max, num_points), wavefunctions[:, 0]**2)
plt.title('Radial Probability Density for Hydrogen Atom Ground State')
plt.xlabel('Radius (m)')
plt.ylabel('Probability Density')
plt.xlim(0, r_max)
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import assoc_laguerre
from scipy.constants import hbar, e, m_e, epsilon_0

def radial_wavefunction(r, n, l):
    # Bohr radius in meters
    a0 = 4 * np.pi * epsilon_0 * hbar**2 / (m_e * e**2)

    # Normalization constant
    rho = 2 * r / (n * a0)
    norm = np.sqrt((2/(n*a0))**3 * np.math.factorial(n-l-1)/(2*n*np.math.factorial(n+l)))

    # Associated Laguerre polynomial
    L = assoc_laguerre(rho, n-l-1, 2*l+1)

    # Complete radial wavefunction
    R = norm * np.exp(-rho/2) * rho**l * L

    return R

# Set up the radial coordinate
r = np.linspace(0, 20, 1000)  # in units of Bohr radius

# Plot radial wavefunctions for different n and l
plt.figure(figsize=(12, 8))

# Ground state (n=1, l=0)
R10 = radial_wavefunction(r, 1, 0)
plt.plot(r, R10, label='n=1, l=0')

# First excited state (n=2, l=0)
R20 = radial_wavefunction(r, 2, 0)
plt.plot(r, R20, label='n=2, l=0')

# First excited state (n=2, l=1)
R21 = radial_wavefunction(r, 2, 1)
plt.plot(r, R21, label='n=2, l=1')

plt.title('Radial Wavefunctions of Hydrogen Atom')
plt.xlabel('r (Bohr radii)')
plt.ylabel('R(r)')
plt.legend()
plt.grid(True)
plt.show()

# Calculate energy levels
def energy_level(n):
    # Rydberg energy in eV
    E0 = 13.6
    return -E0/n**2

# Print first few energy levels
for n in range(1, 4):
    E = energy_level(n)
    print(f"Energy level n={n}: {E:.2f} eV")